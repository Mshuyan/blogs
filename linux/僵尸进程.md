### 僵尸进程是什么样的？

```
riddle@:~/u/exe$ ps -ef | grep riddle
riddle     875     1  0 Feb09 ?        00:00:00 DataServer:AAA
riddle     876   875  0 Feb09 ?        00:00:14 AAA :HubApi
riddle     878   875  0 Feb09 ?        00:00:07 [dserver.x] <defunct>
riddle     879   875  0 Feb09 ?        00:00:16 AAA :HubBck:
riddle     881   875  0 Feb09 ?        00:00:08 [dserver.x] <defunct>
riddle     882   875  0 Feb09 ?        00:00:07 [dserver.x] <defunct>
riddle     883   875  0 Feb09 ?        00:00:08 [dserver.x] <defunct>
riddle     886   875  0 Feb09 ?        00:00:48 [dserver.x] <defunct>
riddle     887   875  0 Feb09 ?        00:00:15 [dserver.x] <defunct>
```
查看进程时，看到<defunct>进程，就是僵尸进程。

僵尸进程的父进程的进程号是 875，它还在正常运行。当你采用 kill -9 命令来终止子进程时，父进程没有waitpid()。

在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵尸进程，无法正常结束，此时即使是root身份kill -9也不能杀死僵尸进程。补救办法是杀死僵尸进程的父进程(僵尸进程的父进程必然存在)，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程。

    僵尸进程是指的父进程已经退出,而该进程dead之后没有进程接受,就成为僵尸进程.(zombie)进程。
    defunct进程只是在process table里还有一个记录，其他的资源没有占用，除非你的系统的process个数的限制已经快超过了，zombie进程不会有更多的坏处。

产生原因：
1.在子进程终止后到父进程调用wait()前的时间里，子进程被称为zombie。
2.网络原因有时会引起僵死进程。

解决方法：
1.设置SIGCLD信号为SIG_IGN，系统将不产生僵死进程。
2.用两次fork()，而且使紧跟的子进程直接退出，是的孙子进程成为孤儿进程，从而init进程将负责清除这个孤儿进程。

### 清除僵尸进程

   找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失。
   如何找到defunct僵尸进程的父进程？很简单，一句命令就够了：ps -ef | grep defunct_process_pid。
   
### 怎样产生僵尸进程的：
    一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。
